<!DOCTYPE html>
<html lang="he" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sound Design for Games Project - Or Zilberberg</title>
    <style>
        :root { --color-a: #39ff14; --color-s: #00d2ff; --color-d: #ff007f; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            background: #050510; color: white; font-family: 'Segoe UI', sans-serif;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; height: 100dvh; margin: 0; overflow: hidden; user-select: none;
            touch-action: none;
        }
        #score-container { font-size: 48px; font-weight: bold; margin-bottom: 2px; color: #fff; text-shadow: 0 0 20px var(--color-s); }
        #combo-display { font-size: 20px; height: 28px; margin-bottom: 4px; transition: all 0.15s; }
        #streak-display { font-size: 16px; height: 22px; margin-bottom: 4px; color: #ff6600; }

        #game-board {
            position: relative; width: 340px; height: 600px;
            background: #0a0a1a; border: 4px solid #1a1a2e; border-radius: 20px;
            display: flex; overflow: hidden; box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        @media (max-width: 400px) {
            #game-board { width: 100vw; height: 75dvh; border-radius: 0; border-left: none; border-right: none; }
            #score-container { font-size: 36px; }
            .touch-zone { height: 120px !important; }
        }
        @media (min-width: 401px) and (max-height: 700px) {
            #game-board { height: 500px; }
        }

        .lane { position: relative; flex: 1; border-right: 1px solid rgba(255,255,255,0.05); }
        .lane:last-child { border-right: none; }
        .lane-flash { background: rgba(255,255,255,0.15) !important; }

        .hit-line { position: absolute; bottom: 80px; width: 100%; height: 4px; background: rgba(255,255,255,0.5); box-shadow: 0 0 15px #fff; z-index: 10; }

        .note {
            position: absolute; width: 60px; height: 60px; border-radius: 50%;
            left: 50%; margin-left: -30px; z-index: 5;
            box-shadow: 0 0 25px currentColor; border: 3px solid rgba(255,255,255,0.7);
            pointer-events: none;
            background: radial-gradient(circle at 35% 35%, rgba(255,255,255,0.3), transparent);
        }
        .note-tail {
            position: absolute; width: 24px; left: 50%; margin-left: -12px;
            background: currentColor; opacity: 0.4; z-index: 4; border-radius: 10px; bottom: 50%;
        }
        .note.holding { box-shadow: 0 0 40px currentColor; border-color: white; }
        .note.holding .note-tail { opacity: 0.8; }

        /* Hit burst animation */
        .note-burst {
            position: absolute; width: 80px; height: 80px; border-radius: 50%;
            left: 50%; margin-left: -40px; z-index: 6; pointer-events: none;
            animation: burstAnim 0.35s ease-out forwards;
        }
        @keyframes burstAnim {
            0% { transform: scale(0.5); opacity: 0.9; }
            100% { transform: scale(1.8); opacity: 0; }
        }

        .key-visual {
            position: absolute; bottom: 10px; width: 60px; height: 60px;
            border: 3px solid white; border-radius: 50%; left: 50%; margin-left: -30px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 28px; opacity: 0.4; z-index: 20;
        }
        .key-active { background: white !important; color: black !important; opacity: 1 !important; box-shadow: 0 0 30px white; }

        .touch-zone {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100px;
            z-index: 25; cursor: pointer;
        }

        .hit-feedback {
            position: absolute; left: 50%; margin-left: -40px; width: 80px; text-align: center;
            font-size: 20px; font-weight: bold; z-index: 30; pointer-events: none;
            animation: feedbackUp 0.6s ease-out forwards;
        }
        /* MISS feedback style */
        .miss-feedback {
            position: absolute; left: 50%; margin-left: -30px; width: 60px; text-align: center;
            font-size: 16px; font-weight: bold; z-index: 30; pointer-events: none; color: #ff4444;
            animation: missFade 0.8s ease-out forwards;
        }
        .streak-bonus-feedback {
            position: absolute; left: 50%; transform: translateX(-50%); top: 40%;
            font-size: 28px; font-weight: bold; z-index: 50; pointer-events: none;
            text-align: center; width: 300px;
            animation: streakPop 1s ease-out forwards;
            text-shadow: 0 0 20px currentColor;
        }
        @keyframes feedbackUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.3); }
        }
        @keyframes missFade {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(30px); }
        }
        @keyframes streakPop {
            0% { opacity: 0; transform: translateX(-50%) scale(0.5); }
            15% { opacity: 1; transform: translateX(-50%) scale(1.2); }
            30% { transform: translateX(-50%) scale(1); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateX(-50%) translateY(-30px); }
        }

        #countdown {
            position: absolute; z-index: 150; width: 100%; height: 100%;
            display: none; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.55); border-radius: 20px; pointer-events: none;
        }
        #countdown-num {
            font-size: 120px; font-weight: bold;
            color: var(--color-s); text-shadow: 0 0 40px var(--color-s), 0 0 80px rgba(0,210,255,0.3);
            animation: countPulse 0.8s ease-out;
        }
        @keyframes countPulse {
            0% { transform: scale(1.8); opacity: 0; }
            30% { transform: scale(1); opacity: 1; }
            100% { opacity: 1; }
        }

        #start-screen, .overlay-screen {
            position: absolute; z-index: 100; text-align: center;
            background: rgba(0,0,0,0.92); width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            border-radius: 20px;
            /* Allow touch events on overlay screens (end screen, start screen) */
            touch-action: auto;
        }
        button {
            padding: 20px 55px; font-size: 30px; background: var(--color-d);
            border: none; color: white; border-radius: 100px; cursor: pointer;
            font-weight: bold; box-shadow: 0 0 30px var(--color-d); transition: 0.2s;
        }
        button:hover { transform: scale(1.08); }

        .lb-title { font-size: 18px; color: var(--color-s); margin: 15px 0 8px; }
        .lb-list { list-style: none; padding: 0; margin: 0 0 15px; width: 80%; }
        .lb-list li {
            display: flex; justify-content: space-between; align-items: center;
            padding: 6px 12px; margin: 3px 0; border-radius: 8px;
            background: rgba(255,255,255,0.05); font-size: 15px;
        }
        .lb-list li.current { background: rgba(0,210,255,0.15); border: 1px solid var(--color-s); }
        .lb-rank { color: #888; width: 24px; }
        .lb-name { flex: 1; text-align: left; margin-left: 8px; }
        .lb-score { font-weight: bold; color: var(--color-s); }

        .name-input {
            background: rgba(255,255,255,0.1); border: 2px solid var(--color-s);
            border-radius: 12px; padding: 12px 16px; font-size: 20px;
            color: white; text-align: center; outline: none; width: 200px; margin: 10px 0;
            /* Ensure mobile keyboard and touch work */
            touch-action: auto;
            -webkit-user-select: text;
            user-select: text;
        }
        .name-input::placeholder { color: rgba(255,255,255,0.3); }

        .mobile-hint { display: none; }
        @media (pointer: coarse) {
            .mobile-hint { display: inline; }
            .desktop-hint { display: none; }
        }
    </style>
</head>
<body>

    <div id="streak-display"></div>
    <div id="combo-display"></div>
    <div id="score-container">0</div>
    <div id="game-board">
        <div class="hit-line"></div>
        <div class="lane" id="lane-0" style="color: var(--color-a);">
            <div class="key-visual">‚Üê</div>
            <div class="touch-zone" data-lane="0"></div>
        </div>
        <div class="lane" id="lane-1" style="color: var(--color-s);">
            <div class="key-visual">‚Üë</div>
            <div class="touch-zone" data-lane="1"></div>
        </div>
        <div class="lane" id="lane-2" style="color: var(--color-d);">
            <div class="key-visual">‚Üí</div>
            <div class="touch-zone" data-lane="2"></div>
        </div>

        <div id="countdown"><div id="countdown-num"></div></div>
    </div>

    <div id="start-screen">
        <h1 style="color: var(--color-s); font-size: 46px;">READY?</h1>
        <p style="opacity:0.6; font-size:15px; margin: 8px 0 20px;">
            <span class="desktop-hint">Use arrow keys: ‚Üê ‚Üë ‚Üí</span>
            <span class="mobile-hint">Tap the lanes!</span>
            <br>Hold for long notes!
        </p>
        <button id="start-btn">PLAY</button>
    </div>

    <audio id="bgm" src="Tap_tap.mp3" preload="auto"></audio>

    <script>
        // =============================================
        //  CONFIG
        // =============================================
        const HIT_LINE_Y     = 520;
        const HIT_WINDOW     = 100;
        const LONG_THRESHOLD = 0.3;
        const LEAD_SEC       = 2.0;
        const COUNTDOWN_SEC  = 3;
        const PRE_SCROLL_SEC = COUNTDOWN_SEC + 0.6;

        const STREAK_MILESTONES = [
            { at: 10,  bonus: 500,   label: '10 STREAK! +500' },
            { at: 20,  bonus: 1000,  label: '20 STREAK! +1000' },
            { at: 30,  bonus: 2000,  label: '30 STREAK! +2000' },
            { at: 40,  bonus: 3000,  label: '40 STREAK! +3000' },
            { at: 50,  bonus: 5000,  label: '50 STREAK! +5000' },
            { at: 60,  bonus: 8000,  label: 'FULL COMBO?! +8000' },
        ];

        const LANE_COLORS = ['var(--color-a)', 'var(--color-s)', 'var(--color-d)'];
        const LANE_HEX    = ['#39ff14', '#00d2ff', '#ff007f'];
        const KEY_TO_LANE = { 'arrowleft': 0, 'arrowup': 1, 'arrowright': 2 };

        // =============================================
        //  ELEMENTS
        // =============================================
        const audio      = document.getElementById('bgm');
        const startBtn   = document.getElementById('start-btn');
        const scoreEl    = document.getElementById('score-container');
        const comboEl    = document.getElementById('combo-display');
        const streakEl   = document.getElementById('streak-display');
        const gameBoard  = document.getElementById('game-board');
        const countdownEl    = document.getElementById('countdown');
        const countdownNumEl = document.getElementById('countdown-num');
        const lanesEls   = [document.getElementById('lane-0'), document.getElementById('lane-1'), document.getElementById('lane-2')];
        const keyVisuals = document.querySelectorAll('.key-visual');

        // =============================================
        //  STATE
        // =============================================
        let score = 0, combo = 0, bestStreak = 0, gameActive = false, gameStartTime = 0;
        let preScrolling = false, preScrollStartTime = 0;
        const heldKeys = new Set();
        const activeTouches = new Map();
        let notes = [];
        let streakMilestonesHit = new Set();

        // =============================================
        //  LEADERBOARD
        // =============================================
        const LB_KEY = 'taptap_leaderboard';
        function getLeaderboard() {
            try { return JSON.parse(localStorage.getItem(LB_KEY)) || []; } catch { return []; }
        }
        function saveLeaderboard(lb) {
            try { localStorage.setItem(LB_KEY, JSON.stringify(lb)); } catch {}
        }
        function addToLeaderboard(name, sc) {
            const lb = getLeaderboard();
            lb.push({ name, score: sc, date: Date.now() });
            lb.sort((a, b) => b.score - a.score);
            if (lb.length > 10) lb.length = 10;
            saveLeaderboard(lb);
            return lb;
        }

        // =============================================
        //  LEVEL DATA (first line removed per request)
        // =============================================
        const levelData = [
          //  {time:0.6,dur:0.2,lane:2},{time:0.8,dur:0.1,lane:2},
            {time:1.0,dur:0.1,lane:2},
            {time:1.3,dur:0.1,lane:2},{time:1.5,dur:0.8,lane:2},{time:1.7,dur:0.3,lane:0},
            {time:2.1,dur:0.2,lane:0},{time:2.3,dur:0.2,lane:2},{time:2.6,dur:0.3,lane:2},
            {time:3.0,dur:1.4,lane:2},{time:3.4,dur:0.3,lane:0},{time:3.9,dur:0.2,lane:1},
            {time:4.5,dur:0.2,lane:0},{time:5.2,dur:0.2,lane:2},{time:5.6,dur:0.2,lane:2},
            {time:6.0,dur:0.4,lane:1},{time:6.5,dur:0.2,lane:2},{time:6.7,dur:0.6,lane:2},
            {time:7.8,dur:0.1,lane:0},{time:8.0,dur:0.1,lane:0},{time:8.2,dur:0.2,lane:1},
            {time:8.4,dur:0.6,lane:2},{time:9.3,dur:0.2,lane:2},{time:9.5,dur:0.4,lane:1},
            {time:10.0,dur:0.8,lane:2},{time:11.3,dur:0.2,lane:0},{time:11.5,dur:0.2,lane:1},
            {time:11.7,dur:0.2,lane:2},{time:12.0,dur:0.4,lane:2},{time:13.4,dur:0.2,lane:1},
            {time:13.9,dur:0.7,lane:2},{time:14.7,dur:0.5,lane:1},{time:15.4,dur:0.8,lane:2},
            {time:16.5,dur:0.2,lane:0},{time:16.7,dur:0.2,lane:1},{time:16.9,dur:0.2,lane:0},
            {time:17.1,dur:0.1,lane:1},{time:17.3,dur:0.9,lane:2},{time:18.2,dur:0.6,lane:1},
            {time:18.9,dur:0.7,lane:2},{time:19.7,dur:0.2,lane:0},{time:20.0,dur:0.2,lane:1},
            {time:20.2,dur:0.1,lane:0},{time:20.4,dur:0.4,lane:2},{time:20.8,dur:0.9,lane:2},
            {time:21.7,dur:0.6,lane:1},{time:22.3,dur:0.4,lane:2},{time:23.0,dur:0.2,lane:0},
            {time:23.2,dur:0.2,lane:1},{time:23.4,dur:0.2,lane:2},{time:23.6,dur:0.2,lane:1},
            {time:23.9,dur:0.2,lane:2},{time:24.1,dur:0.2,lane:0},{time:24.3,dur:0.4,lane:2},
            {time:24.7,dur:0.2,lane:1},{time:25.2,dur:0.4,lane:2},{time:25.6,dur:0.2,lane:0},
            {time:25.8,dur:0.5,lane:2},{time:26.5,dur:0.2,lane:1},{time:26.9,dur:0.2,lane:0},
            {time:27.1,dur:0.2,lane:2},{time:27.3,dur:0.2,lane:1},{time:27.6,dur:0.2,lane:2}
        ];

        function timeToY(gameTime, noteTime) {
            return ((gameTime - noteTime) / LEAD_SEC + 1) * HIT_LINE_Y;
        }

        // =============================================
        //  COUNTDOWN + PRE-SCROLL
        // =============================================
        startBtn.addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';

            // FIX: Unlock audio on mobile ‚Äî play+pause during user gesture
            audio.volume = 0;
            audio.play().then(() => {
                audio.pause();
                audio.currentTime = 0;
                audio.volume = 1;
            }).catch(() => {});

            createNotes();
            preScrolling = true;
            preScrollStartTime = performance.now();
            requestAnimationFrame(preScrollLoop);
            startCountdown();
        });

        function getPreScrollTime() {
            return (performance.now() - preScrollStartTime) / 1000 - PRE_SCROLL_SEC;
        }

        function preScrollLoop() {
            if (!preScrolling) return;
            const t = getPreScrollTime();
            for (const n of notes) {
                if (n.state === 'done' || n.state === 'miss') continue;
                const y = timeToY(t, n.time);
                n.y = y;
                if (y < -80) { n.el.style.display = 'none'; continue; }
                n.el.style.display = '';
                n.el.style.top = y + 'px';
            }
            requestAnimationFrame(preScrollLoop);
        }

        function startCountdown() {
            countdownEl.style.display = 'flex';
            let count = COUNTDOWN_SEC;
            function tick() {
                if (count > 0) {
                    countdownNumEl.textContent = count;
                    countdownNumEl.style.animation = 'none';
                    void countdownNumEl.offsetWidth;
                    countdownNumEl.style.animation = 'countPulse 0.8s ease-out';
                    count--;
                    setTimeout(tick, 1000);
                } else {
                    countdownNumEl.textContent = 'GO!';
                    countdownNumEl.style.animation = 'none';
                    void countdownNumEl.offsetWidth;
                    countdownNumEl.style.animation = 'countPulse 0.8s ease-out';
                    setTimeout(() => {
                        countdownEl.style.display = 'none';
                        preScrolling = false;
                        startGame();
                    }, 600);
                }
            }
            tick();
        }

        function startGame() {
            // FIX: Wait for audio to actually start playing, then sync timer to it
            audio.currentTime = 0;
            audio.play().then(() => {
                // Audio is now truly playing ‚Äî start game timer from NOW
                gameActive = true;
                gameStartTime = performance.now();
                requestAnimationFrame(gameLoop);
            }).catch(() => {
                // Audio failed ‚Äî fall back to original timing
                gameActive = true;
                gameStartTime = preScrollStartTime + PRE_SCROLL_SEC * 1000;
                requestAnimationFrame(gameLoop);
            });
        }

        function getTime() { return (performance.now() - gameStartTime) / 1000; }

        function createNotes() {
            levelData.forEach(d => {
                const el = document.createElement('div');
                el.className = 'note';
                const isLong = d.dur > LONG_THRESHOLD;
                if (isLong) {
                    const tail = document.createElement('div');
                    tail.className = 'note-tail';
                    tail.style.height = ((d.dur / LEAD_SEC) * HIT_LINE_Y) + 'px';
                    el.appendChild(tail);
                }
                lanesEls[d.lane].appendChild(el);
                notes.push({ el, lane: d.lane, time: d.time, dur: d.dur, isLong, state: 'wait', holdTicks: 0, holdStart: 0, y: -100 });
            });
        }

        // =============================================
        //  GAME LOOP
        // =============================================
        function gameLoop() {
            if (!gameActive) return;
            const t = getTime();

            for (const n of notes) {
                if (n.state === 'done' || n.state === 'miss') continue;

                // FIX: Held notes ‚Äî pin to hit line, shrink tail
                if (n.state === 'held') {
                    const isHeld = heldKeys.has(n.lane) || isTouchHeld(n.lane);
                    const endTime = n.time + n.dur;
                    const elapsed = t - n.holdStart;
                    const ticks = Math.floor(elapsed / 0.12);

                    // Pin at hit line instead of continuing to scroll
                    n.el.style.top = HIT_LINE_Y + 'px';
                    n.y = HIT_LINE_Y;

                    // Shrink tail as hold progresses
                    const tailEl = n.el.querySelector('.note-tail');
                    if (tailEl) {
                        const remaining = Math.max(0, endTime - t);
                        tailEl.style.height = Math.max(0, (remaining / LEAD_SEC) * HIT_LINE_Y) + 'px';
                    }

                    if (ticks > n.holdTicks) {
                        score += (ticks - n.holdTicks) * 20;
                        n.holdTicks = ticks;
                        scoreEl.innerText = score;
                    }
                    if (!isHeld || t >= endTime) {
                        n.state = 'done';
                        showBurst(n.lane, HIT_LINE_Y);
                        n.el.remove(); // FIX: remove from DOM completely
                        if (t >= endTime - 0.15) {
                            score += 100;
                            scoreEl.innerText = score;
                            showFeedback(n.lane, 'HELD!', '#00ffcc');
                        }
                    }
                    continue;
                }

                // Normal scrolling for active/wait notes
                const y = timeToY(t, n.time);
                n.y = y;

                if (y < -80) { n.el.style.display = 'none'; continue; }
                n.el.style.display = '';
                n.el.style.top = y + 'px';

                // FIX: Miss ‚Äî show MISS text, remove from DOM
                if (y > HIT_LINE_Y + HIT_WINDOW + 20) {
                    n.state = 'miss';
                    combo = 0;
                    updateCombo();
                    showMiss(n.lane, y);
                    n.el.remove();
                }
            }

            const lastT = levelData[levelData.length - 1].time + 4;
            if (t > lastT) { gameActive = false; showEnd(); return; }
            requestAnimationFrame(gameLoop);
        }

        function isTouchHeld(lane) {
            for (const [, l] of activeTouches) { if (l === lane) return true; }
            return false;
        }

        // =============================================
        //  LANE PRESS / RELEASE
        // =============================================
        function lanePress(lane) {
            if (!gameActive) return;
            keyVisuals[lane].classList.add('key-active');
            lanesEls[lane].classList.add('lane-flash');
            tryHit(lane);
        }

        function laneRelease(lane) {
            if (!heldKeys.has(lane) && !isTouchHeld(lane)) {
                keyVisuals[lane].classList.remove('key-active');
                lanesEls[lane].classList.remove('lane-flash');
            }
        }

        // =============================================
        //  KEYBOARD INPUT
        // =============================================
        window.addEventListener('keydown', e => {
            if (['ArrowLeft','ArrowDown','ArrowRight','ArrowUp'].includes(e.key)) e.preventDefault();
            if (!gameActive) return;
            const lane = KEY_TO_LANE[e.key.toLowerCase()];
            if (lane === undefined) return;
            if (!heldKeys.has(lane)) {
                heldKeys.add(lane);
                lanePress(lane);
            }
        });

        window.addEventListener('keyup', e => {
            const lane = KEY_TO_LANE[e.key.toLowerCase()];
            if (lane === undefined) return;
            heldKeys.delete(lane);
            laneRelease(lane);
        });

        // =============================================
        //  TOUCH INPUT
        // =============================================
        function getTouchLane(touch) {
            const el = document.elementFromPoint(touch.clientX, touch.clientY);
            if (!el) return -1;
            const zone = el.closest('.touch-zone') || el.closest('.lane');
            if (!zone) return -1;
            const laneEl = zone.classList.contains('lane') ? zone : zone.parentElement;
            return lanesEls.indexOf(laneEl);
        }

        gameBoard.addEventListener('touchstart', e => {
            // Don't block touch on overlay screens (end screen input/buttons)
            if (e.target.closest('.overlay-screen') || e.target.closest('#start-screen')) return;
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const lane = getTouchLane(touch);
                if (lane === -1) continue;
                const wasHeld = isTouchHeld(lane);
                activeTouches.set(touch.identifier, lane);
                if (!wasHeld) lanePress(lane);
            }
        }, { passive: false });

        gameBoard.addEventListener('touchmove', e => {
            if (e.target.closest('.overlay-screen') || e.target.closest('#start-screen')) return;
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const newLane = getTouchLane(touch);
                const oldLane = activeTouches.get(touch.identifier);
                if (oldLane !== undefined && newLane !== oldLane) {
                    activeTouches.set(touch.identifier, newLane);
                    if (oldLane !== -1 && !isTouchHeld(oldLane)) laneRelease(oldLane);
                    if (newLane !== -1) {
                        keyVisuals[newLane].classList.add('key-active');
                        lanesEls[newLane].classList.add('lane-flash');
                    }
                }
            }
        }, { passive: false });

        gameBoard.addEventListener('touchend', e => {
            if (e.target.closest('.overlay-screen') || e.target.closest('#start-screen')) return;
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const lane = activeTouches.get(touch.identifier);
                activeTouches.delete(touch.identifier);
                if (lane !== undefined && lane !== -1) laneRelease(lane);
            }
        }, { passive: false });

        gameBoard.addEventListener('touchcancel', e => {
            for (const touch of e.changedTouches) {
                const lane = activeTouches.get(touch.identifier);
                activeTouches.delete(touch.identifier);
                if (lane !== undefined && lane !== -1) laneRelease(lane);
            }
        });

        // =============================================
        //  HIT LOGIC
        // =============================================
        function tryHit(lane) {
            let best = null, bestDist = Infinity;
            for (const n of notes) {
                if (n.lane !== lane || (n.state !== 'wait' && n.state !== 'active')) continue;
                const dist = Math.abs(n.y - HIT_LINE_Y);
                if (dist < HIT_WINDOW && dist < bestDist) { bestDist = dist; best = n; }
            }
            if (!best) return;

            let pts, txt, clr;
            if (bestDist < 25)      { pts = 300; txt = 'PERFECT!'; clr = '#ffdd00'; }
            else if (bestDist < 55) { pts = 200; txt = 'GREAT!';   clr = '#39ff14'; }
            else                    { pts = 100; txt = 'GOOD';     clr = '#aaaaaa'; }

            combo++;
            if (combo > bestStreak) bestStreak = combo;
            let mult = 1 + Math.floor(combo / 10) * 0.5;
            pts = Math.round(pts * mult);
            score += pts;

            for (const m of STREAK_MILESTONES) {
                if (combo === m.at && !streakMilestonesHit.has(m.at)) {
                    streakMilestonesHit.add(m.at);
                    score += m.bonus;
                    showStreakBonus(m.label);
                }
            }

            scoreEl.innerText = score;
            updateCombo();
            showFeedback(lane, txt, clr);

            if (best.isLong) {
                // Long note ‚Äî pin to hit line, start hold
                best.state = 'held';
                best.holdStart = getTime();
                best.el.classList.add('holding');
                best.el.style.top = HIT_LINE_Y + 'px'; // FIX: pin immediately
            } else {
                // FIX: Short note ‚Äî burst + remove from DOM completely
                best.state = 'done';
                showBurst(lane, best.y);
                best.el.remove();
            }
        }

        // =============================================
        //  BURST EFFECT (when note is hit)
        // =============================================
        function showBurst(lane, yPos) {
            const burst = document.createElement('div');
            burst.className = 'note-burst';
            burst.style.top = yPos + 'px';
            burst.style.background = `radial-gradient(circle, ${LANE_HEX[lane]}66, transparent)`;
            burst.style.boxShadow = `0 0 30px ${LANE_HEX[lane]}`;
            lanesEls[lane].appendChild(burst);
            setTimeout(() => burst.remove(), 350);
        }

        // =============================================
        //  UI HELPERS
        // =============================================
        function showFeedback(lane, text, color) {
            const el = document.createElement('div');
            el.className = 'hit-feedback';
            el.style.bottom = '150px';
            el.style.color = color;
            el.textContent = text;
            lanesEls[lane].appendChild(el);
            setTimeout(() => el.remove(), 600);
        }

        // FIX: Show MISS text when a note is missed
        function showMiss(lane, yPos) {
            const el = document.createElement('div');
            el.className = 'miss-feedback';
            el.style.top = Math.min(yPos, HIT_LINE_Y + 30) + 'px';
            el.textContent = 'MISS';
            lanesEls[lane].appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function showStreakBonus(label) {
            const el = document.createElement('div');
            el.className = 'streak-bonus-feedback';
            el.style.color = '#ff8800';
            el.textContent = label;
            gameBoard.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function updateCombo() {
            if (combo >= 5) {
                comboEl.textContent = combo + ' COMBO';
                comboEl.style.color = combo >= 30 ? '#ff3366' : combo >= 20 ? '#ff8800' : combo >= 10 ? '#ffdd00' : '#ffaa00';
                comboEl.style.textShadow = `0 0 12px ${comboEl.style.color}`;
            } else { comboEl.textContent = ''; }
            if (bestStreak >= 5) streakEl.textContent = 'Best streak: ' + bestStreak;
        }

        // =============================================
        //  END SCREEN + LEADERBOARD
        // =============================================
        function showEnd() {
            // Re-enable touch on the game board area for the overlay
            const div = document.createElement('div');
            div.className = 'overlay-screen';

            const lb = getLeaderboard();
            const isTopScore = lb.length < 10 || score > (lb[lb.length - 1]?.score || 0);

            let html = `<h1 style="color:var(--color-s);font-size:36px;margin:0 0 5px">GAME OVER</h1>`;
            html += `<p style="font-size:38px;margin:8px 0;font-weight:bold">${score.toLocaleString()}</p>`;
            if (bestStreak >= 5) html += `<p style="font-size:16px;color:#ff8800;margin:4px 0">Best Streak: ${bestStreak}</p>`;

            if (isTopScore && score > 0) {
                html += `
                    <p style="font-size:14px;color:var(--color-a);margin:10px 0 5px">New high score! Enter your name:</p>
                    <input class="name-input" id="name-input" type="text" placeholder="Your name" maxlength="12"
                           autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
                    <button id="save-btn" style="padding:12px 40px;font-size:22px;margin-top:8px">SAVE</button>`;
            } else {
                html += buildLeaderboardHTML(lb, -1);
                html += `<button onclick="location.reload()" style="margin-top:12px;padding:14px 45px;font-size:24px">PLAY AGAIN</button>`;
            }

            div.innerHTML = html;
            gameBoard.appendChild(div);

            if (isTopScore && score > 0) {
                const saveBtn = document.getElementById('save-btn');
                const nameInput = document.getElementById('name-input');

                // Focus with delay to ensure mobile keyboard opens
                setTimeout(() => {
                    nameInput.focus();
                    nameInput.click();
                }, 300);

                const doSave = () => {
                    const name = nameInput.value.trim() || 'Player';
                    const newLb = addToLeaderboard(name, score);
                    const myIdx = newLb.findIndex(e => e.score === score && e.name === name);
                    div.innerHTML = `
                        <h1 style="color:var(--color-s);font-size:36px;margin:0 0 5px">GAME OVER</h1>
                        <p style="font-size:38px;margin:8px 0;font-weight:bold">${score.toLocaleString()}</p>
                        ${bestStreak >= 5 ? `<p style="font-size:16px;color:#ff8800;margin:4px 0">Best Streak: ${bestStreak}</p>` : ''}
                        ${buildLeaderboardHTML(newLb, myIdx)}
                        <button onclick="location.reload()" style="margin-top:12px;padding:14px 45px;font-size:24px">PLAY AGAIN</button>`;
                };
                saveBtn.addEventListener('click', doSave);
                nameInput.addEventListener('keydown', e => { if (e.key === 'Enter') doSave(); });
            }
        }

        function buildLeaderboardHTML(lb, highlightIdx) {
            if (lb.length === 0) return '';
            const medals = ['ü•á', 'ü•à', 'ü•â'];
            let html = `<div class="lb-title">LEADERBOARD</div><ul class="lb-list">`;
            lb.forEach((entry, i) => {
                html += `<li class="${i === highlightIdx ? 'current' : ''}">
                    <span class="lb-rank">${medals[i] || (i + 1)}</span>
                    <span class="lb-name">${escHtml(entry.name)}</span>
                    <span class="lb-score">${entry.score.toLocaleString()}</span></li>`;
            });
            return html + `</ul>`;
        }

        function escHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
    </script>
</body>
</html>
